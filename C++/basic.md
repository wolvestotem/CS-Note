# Basic

## 类和内存

C++程序的内存格局通常分为四个区：***全局数据区(data area)，代码区(code area)，栈区(stack area)，堆区(heap area)(即自由存储区)***。全局数据区存放全局变量，静态数据和常量；所有类成员函数和非成员函数代码存放在代码区；为运行函数而分配的局部变量、函数参数、返回数据、返回地址等存放在栈区；余下的空间都被称为堆区。根据这个解释，我们可以得知在类的定义时，**类成员函数是被放在代码区，而类的静态成员变量在类定义时就已经在全局数据区分配了内存，因而它是属于类的。对于非静态成员变量，我们是在类的实例化过程中(构造对象)才在栈区或者堆区为其分配内存，是为每个对象生成一个拷贝，所以它是属于对象的。**

应当说明，常说的“某某对象的成员函数”，是从逻辑的角度而言的，而成员函数的存储方式，是从物理的角度而言的，二者是不矛盾的。

下面我们再来讨论下类的静态成员函数和非静态成员函数的区别：***静态成员函数和非静态成员函数都是在类的定义时放在内存的代码区的，因而可以说它们都是属于类的***，但是类为什么只能直接调用静态类成员函数，而非静态类成员函数(即使函数没有参数)只有类对象才能调用呢？原因是类的非静态类成员函数其实都内含了一个指向类对象的指针型参数(即this指针)，因而只有类对象才能调用(此时this指针有实值)。

需要说明，不论成员函数在类内定义还是在类外定义，成员函数的代码段都用同一种方式存储。不要将成员函数的这种存储方式和inline(内联)函数的概念混淆。不要误以为用inline声明(或默认为inline)的成员函数，其代码段占用对象的存储空间，而不用inline声明的成员函数，其代码段不占用对象的存储空间。**不论是否用inline声明(或默认为inline)，成员函数的代码段都不占用对象的存储空间。用inline声明的作用是在调用该函数时，将函数的代码段复制插人到函数调用点，而若不用inline声明，在调用该函数时，流程转去函数代码段的入口地址，在执行完该函数代码段后，流程返回函数调用点。**inline与成员函数是否占用对象的存储空间无关，它们不属于同一个问題，不应搞混。

## class和struct区别

- C的struct与C++的class的区别：struct只是作为一种复杂数据类型定义，不能用于面向对象编程。
- C++中的struct和class的区别：对于成员访问权限以及继承方式，class中默认的是private的，而struct中则是public的。class还可以用于表示模板类型，struct则不行。

## protected、private、public成员、继承

在没有继承的情况下，protected跟private相同，在派生类的时候才出现分化。priavte对派生类不可见，但是派生类可以访问基类protected成员。
![权限](./picture/派生类权限.png)

## const

**常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的,就如同常数一样使用。因为常量在定以后就不能被修改，所以定义时必须初始化！类中const成员必须通过初始化列表初始化**

```C++
const int function(const int var) const{}
```

返回值const，但是因为一般使用copy constructor，此const没有意义，可以返回给任意

函数参数const，传递过来的参数var不能改变，保护只读参数

函数是const，,在这个函数中的任何试图改变成员变量和调用非const成员函数的操作都被视为非法。

```C++
int Stack::functiont(void)  const 
{ 
   ++ m_num; // 编译错误，企图修改数据成员 m_num 
   Pop();  // 编译错误，企图调用非const 函数 
   return m_num; 
 }
 ```

只能使用const引用指向const变量，只能指向const的指针指向cosnt变量

```C++
const int *p; //p是指向const常量的指针
int * const p; //p指针是常量指向地址不可更改
```

## static用法
一、 static全局变量与普通的全局变量有什么区别 ?
　 　全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。
　　  全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。
　　  这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。 
　　  static全局变量只初使化一次，防止在其他文件单元中被引用; 
二、static局部变量和普通局部变量有什么区别 ？
 　　把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。  
       static局部变量只被初始化一次，下一次依据上一次结果值；
三、static函数与普通函数有什么区别？
　　 static函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static修饰的函数)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件.
　　static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。
**当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性**
四、默认值为零


## C++11特性

1. lambda函数
[](int a, int b){return a<b;}
2. 右值引用
int&& q=42;
int&& p=foo;//false
int&& qux=foo++;
3. 智能指针
shared_ptr
它有一个叫做共享所有权(sharedownership)的概念。shared_ptr的目标非常简单：多个指针可以同时指向一个对象，当最后一个shared_ptr离开作用域时，内存才会自动释放。shared_ptr中所实现的本质是引用计数(reference counting)，也就是说shared_ptr是支持复制的，复制一个shared_ptr的本质是对这个智能指针的引用次数加1，而当这个智能指针的引用次数降低到0的时候，该对象自动被析构
循环引用
weak_ptr
我理解的weak_ptr和shared_ptr的最大区别在于weak_ptr在指向一个对象的时候不会增加其引用计数，因此你可以用weak_ptr去指向一个对象并且在weak_ptr仍然指向这个对象的时候析构它，此时你再访问weak_ptr的时候，weak_ptr其实返回的会是一个空的shared_ptr。
4. 初始化列表
5. 基于范围的for循环
`for(int x: arr)`
6. final、override
C++借由虚函数实现运行时多态，但C++的虚函数又很多脆弱的地方：

    无法禁止子类重写它。可能到某一层级时，我们不希望子类继续来重写当前虚函数了。
    容易不小心隐藏父类的虚函数。比如在重写时，不小心声明了一个签名不一致但有同样名称的新函数。

C++11提供了`final`来禁止虚函数被重写/禁止类被继承，`override`来显示地重写虚函数。 这样编译器给我们不小心的行为提供更多有用的错误和警告。
```C++
struct Base1 final { };     
struct Derived1 : Base1 {};         // 编译错：Base1不允许被继承

struct Base2 {
    virtual void f1() final;
    virtual void f2();
};
struct Derived2 : Base2 {
    virtual void f1();              // 编译错：f1不允许重写
    virtual void f2(int) override;  // 编译错：父类中没有 void f2(int)
};
```

7. unordered_set unordered_map

## 虚函数

虚函数表是全局共享的元素,即全局仅有一个.

虚函数表类似一个数组,类对象中存储vptr指针,指向虚函数表.

即虚函数表不是函数,不是程序代码,不肯能存储在代码段.虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定,即虚函数表的大小可以确定,即大小是在编译时期确定的,不必动态分配内存空间存储虚函数表,所以不再堆中.根据以上特征,虚函数表类似于类中静态成员变量.静态成员变量也是全局共享,大小确定.*所以虚函数表和静态成员变量一样,存放在全局数据区.*

### 动态联编

基类定义了虚函数，子类可以重写该函数，当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态地调用属于子类的该函数，且这样的函数调用是无法在编译期间确认的，而是在运行期确认，也叫做迟绑定。在此模型中，non static 数据成员被放置到对象内部，static数据成员， static and nonstatic 函数成员均被放到对象之外。对于虚函数的支持则分两步完成：
1.每一个class产生一堆指向虚函数的指针，放在表格之中。这个表格称之为虚函数表（virtual table，vtbl）。
2.每一个对象被添加了一个指针，指向相关的虚函数表vtbl。通常这个指针被称为vptr。vptr的设定和重置都由每一个class的构造函数，析构函数和拷贝赋值运算符自动完成。

### 构造顺序

无继承时：
1、分配内存
2、初始化列表之前赋值虚表指针
3、列表初始化
4、执行构造函数体

有继承时：
1、分配内存
2、基类构造过程（按照无继承来）
3、初始化子类虚表指针
4、子类列表初始化
5、执行子类构造函数体

### 纯虚函数

```C++
virtual void Show() = 0;
```

包含纯虚函数的类叫做抽象类（接口类），抽象类不能实例化出对象。纯虚函数在派生类中被重定义后，才可以实例化出对象。在纯虚函数这儿，子类必须重写父类，否则就没意义

## 面向对象特点

一、三个基本特征
向对象的三个基本特征是：封装、继承、多态。

封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。
继承概念的实现方式有三类：实现继承、接口继承和可视继承。
Ø 实现继承是指使用基类的属性和方法而无需额外编码的能力；
Ø 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；
Ø 可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。

多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。

实现多态，有二种方式，覆盖，重载。
覆盖，是指子类重新定义父类的虚函数的做法。
重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）

## 编译过程

预编译
所谓预编译头，就是把一个工程中要使用的一些标准头文件预先编译，以后该工程编译时，不再编译这部分头文件，仅仅使用预编译的结果。这样可以加快编译速度，节省时间。

编译
以预编译的输出作为输入，利用C++运行库，通过词法分析和语法分析，在确认所有的指令都符合语法规则时，将其翻译成等价的中间代码表示或者是汇编语言。 

汇编
汇编阶段的主要工作是将经过编译、优化后的，**以汇编语言的形式存在的程序转化为机器可识别的二进制代码，从而得到相应的目标文件。**
目标文件通常由数据段和代码段组成。代码段保存的是程序的指令，该段一般是可读和可执行的，但一般是不可写的。数据段主要用来保存程序中所定义的或者需要用到的全局变量、静态数据(局部变量是在运行阶段生成)。数据段一般是可读可写的。 

链接
经历了汇编之后的程序是后缀为.obj形式的文件，仍然是不可执行的，只有经过链接阶段，将程序所引用的外部文件关联起来之后，形成.exe后缀的文件之后，才是可执行的。程序中可能引用了定义在其他外部文件中的变量或者函数，比如某些库函数，而链接阶段所做的主要事情就是将这些相关联的文件链接起来，使得所有这些目标文件成为一个能够被操作系统装入执行的统一的整体。

链接方式具体可分为动态链接与静态链接两种。

动态链接：
采用该链接方式表明，需要链接的代码是存放在动态链接库或者某个共享对象的目标文件中，链接程序(Link.exe)此时所做的只是在最终的可执行程序中记录下共享对象的名字和其他少量的登记信息，不会想需要链接的代码拷贝到最终的可执行程序中，在此可执行文件被执行时，
动态链接库的全部内容将被映射到运行时相应进程的虚地址空间，动态链接程序将根据可执行程序中登记的信息找到相应的函数代码。采用动态链接方式最终生成的可执行程序较小，因为不会将动态库中的内容拷贝到可执行程序中。但需要注意的是，可执行程序在运行时需要目标主机上存在相应的动态库和环境。

静态链接：
采用该链接方式，需要链接的代码会被链接程序从相应的静态链接库中拷贝到可执行程序之中，在可执行程序运行时，这些代码会装入到该进程相应的地址空间之中。因此，采用静态链接库的方式，最终生成的可执行文件相对较大。 

### 动静态链接
在C/C++中，这些独立的编译单元包括obj文件（一般的源程序编译而成）、lib文件（静态链接的函数库）、dll文件（动态链接的函数库）等。

静态链接方式：在程序执行之前完成所有的组装工作，生成一个可执行的目标文件（EXE文件）。

动态链接方式：在程序已经为了执行被装入内存之后完成链接工作，并且在内存中一般只保留该编译单元的一份拷贝。
静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib中的指令都被直接包含在最终生成的EXE文件中了。但是若使用DLL，该DLL不必被包含在最终的EXE文件中，EXE文件执行时可以“动态”地引用和卸载这个与EXE独立的DLL文件。

采用动态链接库的优点：（1）更加节省内存；（2）DLL文件与EXE文件独立，只要输出接口不变，更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性。

## new VS malloc()
1. new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。
2. new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合**类型安全性**的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
3. new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。
4. 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。
5. 使用new操作符来分配对象内存时会经历三个步骤：

    第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。
    第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。
    第三部：对象构造完成后，返回一个指向该对象的指针。

使用delete操作符来释放对象内存时会经历两个步骤：

    第一步：调用对象的析构函数。
    第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。

总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。
6. C++提供了new[]与delete[]来专门处理数组类型:

	A * ptr = new A[10];//分配10个A对象

使用new[]分配的内存必须使用delete[]进行释放：

    delete [] ptr;

new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。

至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小

7. operator new ,  funcion malloc()

## 字节对齐

```C++
struct MyStruct 
{ 
char dda;　　　　　　　　　　　　　　//偏移量为0，满足对齐方式，dda占用1个字节； 
double dda1;　　　　　　　　　　　　//下一个可用的地址的偏移量为1，不是sizeof(double)=8的倍数，需要补足7个字节才能使偏移量变为8（满足对齐方式），因此VC自动填充7个字节，dda1存放在偏移量为8的地址上，它占用8个字节。 
int type；　　　　　　　　　　　　　//下一个可用的地址的偏移量为16，是sizeof(int)=4的倍数，满足int的对齐方式，所以不需要VC自动填充，type存放在偏移量为16的地址上，它占用4个字节。 
}；　　　　　　　　　　　　　　　　　//所有成员变量都分配了空间，空间总的大小为1+7+8+4=20，不是结构的节边界数（即结构中占用最大空间的类型所占用的字节数sizeof(double)=8）的倍数，所以需要填充4个字节，以满足结构的大小为sizeof(double)=8的倍数。
```

## 迭代器失效
总结：迭代器失效分三种情况考虑，也是非三种数据结构考虑，分别为数组型，链表型，树型数据结构。

数组型数据结构：该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert(*iter)(或erase(*iter))，然后在iter++，是没有意义的。解决方法：erase(*iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter);

链表型数据结构：对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++).

树形数据结构： 使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。

