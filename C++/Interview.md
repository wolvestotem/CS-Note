# Interview problems

## 类和内存

C++程序的内存格局通常分为四个区：***全局数据区(data area)，代码区(code area)，栈区(stack area)，堆区(heap area)(即自由存储区)***。全局数据区存放全局变量，静态数据和常量；所有类成员函数和非成员函数代码存放在代码区；为运行函数而分配的局部变量、函数参数、返回数据、返回地址等存放在栈区；余下的空间都被称为堆区。根据这个解释，我们可以得知在类的定义时，**类成员函数是被放在代码区，而类的静态成员变量在类定义时就已经在全局数据区分配了内存，因而它是属于类的。对于非静态成员变量，我们是在类的实例化过程中(构造对象)才在栈区或者堆区为其分配内存，是为每个对象生成一个拷贝，所以它是属于对象的。**

应当说明，常说的“某某对象的成员函数”，是从逻辑的角度而言的，而成员函数的存储方式，是从物理的角度而言的，二者是不矛盾的。

下面我们再来讨论下类的静态成员函数和非静态成员函数的区别：***静态成员函数和非静态成员函数都是在类的定义时放在内存的代码区的，因而可以说它们都是属于类的***，但是类为什么只能直接调用静态类成员函数，而非静态类成员函数(即使函数没有参数)只有类对象才能调用呢？原因是类的非静态类成员函数其实都内含了一个指向类对象的指针型参数(即this指针)，因而只有类对象才能调用(此时this指针有实值)。

需要说明，不论成员函数在类内定义还是在类外定义，成员函数的代码段都用同一种方式存储。不要将成员函数的这种存储方式和inline(内联)函数的概念混淆。不要误以为用inline声明(或默认为inline)的成员函数，其代码段占用对象的存储空间，而不用inline声明的成员函数，其代码段不占用对象的存储空间。**不论是否用inline声明(或默认为inline)，成员函数的代码段都不占用对象的存储空间。用inline声明的作用是在调用该函数时，将函数的代码段复制插人到函数调用点，而若不用inline声明，在调用该函数时，流程转去函数代码段的入口地址，在执行完该函数代码段后，流程返回函数调用点。**inline与成员函数是否占用对象的存储空间无关，它们不属于同一个问題，不应搞混。

## class和struct区别

- C的struct与C++的class的区别：struct只是作为一种复杂数据类型定义，不能用于面向对象编程。
- C++中的struct和class的区别：对于成员访问权限以及继承方式，class中默认的是private的，而struct中则是public的。class还可以用于表示模板类型，struct则不行。

## const

**常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的,就如同常数一样使用。因为常量在定以后就不能被修改，所以定义时必须初始化！类中const成员必须通过初始化列表初始化**

```C++
const int function(const int var) const{}
```

返回值const，但是因为一般使用copy constructor，此const没有意义，可以返回给任意

函数参数const，传递过来的参数var不能改变，保护只读参数

函数是const，,在这个函数中的任何试图改变成员变量和调用非const成员函数的操作都被视为非法。

```C++
int Stack::functiont(void)  const 
{ 
   ++ m_num; // 编译错误，企图修改数据成员 m_num 
   Pop();  // 编译错误，企图调用非const 函数 
   return m_num; 
 }
 ```

只能使用const引用指向const变量，只能指向const的指针指向cosnt变量

```C++
const int *p; //p是指向const常量的指针
int * const p; //p指针是常量指向地址不可更改
```

